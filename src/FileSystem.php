<?php
/*
Copyright (C) 2018 Pro Computer James R. Steel

This program is distributed WITHOUT ANY WARRANTY; without 
even the implied warranty of MERCHANTABILITY or FITNESS FOR 
A PARTICULAR PURPOSE. See the GNU General Public License 
for more details.
*/
/* 
    Created on  : Jan 01, 2016, 12:00:00 PM
    Organization: Pro Computer
    Author      : James R. Steel
    Description : File system helper functions
*/
namespace Procomputer\Pcclib;

/**
 * 
 */
class FileSystem extends Common {

    /**
     * Switch: throw errors or return an Error object when a major error occurrs.
     * @var boolean
     */
    private static $_throwErrors = true;
    
    /**
     * The flag that indicates debug mode ON/OFF.
     * @var boolean
     */
    private static $_debug = false;

    /**
     * The array of string debug messages generated.
     * @var array
     */
    private static $_debug_msg = [];

    /**
     * Array of data to shut down when PHP script exits.
     * @var array
     */
    private static $_shutdown = [];
    
    /**
     * Flag that indicates shutdown initialized.
     * @var boolean
     */
    private static $_shutdownInit = false;

    /**
     * When TRUE the OS is MS, else not MS.
     *
     * @var boolean
     */
    private static $_osWindows = null;

    /**
     * Sets the throw errors setting that determines whether an exception is thrown on severe 
     * errors or an Error object is returned on severe errors.
     * @param boolean $throw (optional) Sets the throw errors setting. If null the setting is not changed.
     * @return boolean Returns the previous throw errors setting..
     */
    public static function throwErrors($throw = null) {
        $return = self::$_throwErrors;
        if(null !== $throw) {
            self::$_throwErrors = (bool)$throw;
        }
        return $return;
    }
    
    /**
     * Renames a file or folder.
     *
     * @param string $oldName  Item to rename.
     * @param string $newName  New item name.
     *
     * @return boolean  Returns TRUE if successful else FALSE.
     */
    public static function renameFile($oldName, $newName) {
        if(!is_string($oldName) || !strlen(trim($oldName))) {
            $param = 'oldName';
        }
        elseif(!is_string($newName) || !strlen(trim($newName))) {
            $param = 'newName';
        }
        if(isset($param)) {
            $var = Types::getVartype($$param, 32);
            $msg = "cannot rename file: invalid '{$param}' file/path parameter '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        
        if(! file_exists($oldName)) {
            $var = Types::getVartype($oldName);
            $msg = "cannot rename file: file not found: {$var}";
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg);
            }
            return new Error($msg, Constant::E_FILE_NOT_FOUND);
        }
        
        // PhpErrorHandler traps php errors if any and saves to $phpErrHandler->lastError
        $phpErrHandler = new PhpErrorHandler();
        $res = $phpErrHandler->call(function()use($oldName, $newName){
            return rename($oldName, $newName);
        });
        if(false === $res) {
            // Create an error message including the error message generated by the 'rename()' 
            // function in the closure function above and saved to $phpErrHandler->lastError
            $code = Constant::E_FILE_RENAME;
            $msg = $phpErrHandler->getErrorMsg("rename() method failed", "Cannot rename '{$oldName}' to '{$newName}'");
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, $code);
            }
            return new Error($msg, $code);
        }
        return true;
    }

    /**
     * Copies a file.
     *
     * @param string   $source      Source file path.
     * @param string   $dest        Destination file path.
     * @param boolean  $overwrite   (optional) Safety switch: only when TRUE is existing file overwritten.
     *
     * @return boolean Returns TRUE on success, FALSE on fail.
     */
    public static function copyFile($source, $dest, $overwrite = false) {
        if(!is_string($source) || !strlen(trim($source))) {
            $param = 'source';
        }
        elseif(!is_string($dest) || !strlen(trim($dest))) {
            $param = 'dest';
        }
        if(isset($param)) {
            $var = Types::getVarType($$param);
            $msg = "cannot copy file: invalid '{$param}' file/path parameter '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }

        $realSource = realpath($source);
        if(false === $realSource || !is_file($realSource)) {
            $var = Types::getVarType($source);
            $msg = "cannot copy file: source is not a file: '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, Constant::E_FILE_NOT_FOUND);
            }
            return new Error($msg, Constant::E_FILE_NOT_FOUND);
        }

        if(!$overwrite && file_exists($dest)) {
            $var = Types::getVarType($dest);
            $msg = "cannot copy file: file exists and overwrite not allowed: '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, Constant::E_FILE_EXISTS);
            }
            return new Error($msg, Constant::E_FILE_EXISTS);
        }

        // PhpErrorHandler traps php errors if any and saves to $phpErrHandler->lastError
        $phpErrHandler = new PhpErrorHandler();
        $res = $phpErrHandler->call(function()use($realSource, $dest){
            return copy($realSource, $dest);
        });
        if(false === $res) {
            // Create an error message including the error message generated by the 'rename()' 
            // function in the closure function above and saved to $phpErrHandler->lastError
            $errno = Constant::E_FILE_COPY;
            $msg = $phpErrHandler->getErrorMsg("copy() method failed", "Cannot copy '{$realSource}' to '{$dest}'");
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, $errno);
            }
            return new Error($msg, $errno);
        }
        return $res;
    }

    /**
     * Copies data to a file.
     *
     * @param string   $data        String data to write.
     * @param string   $file        Destination file path.
     * @param boolean  $overwrite   (optional) Safety switch: only when TRUE is existing file overwritten.
     *
     * @return boolean Returns TRUE on success, FALSE on fail.
     */
    public static function filePutContents($data, $file, $overwrite = false) {
        if(!is_string($data) || !strlen(trim($data))) {
            $param = 'data';
            $max = 32;
        }
        elseif(!is_string($file) || !strlen(trim($file))) {
            $param = 'file';
        }
        if(isset($param)) {
            $var = Types::getVarType($$param, isset($max) ? $max : 256);
            $msg = "cannot write file data: invalid '{$param}' file/path parameter '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        
        if(!$overwrite && is_file($file)) {
            $var = Types::getVarType($file);
            $msg = "cannot write file data: file exists and overwrite not allowed: '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, Constant::E_FILE_EXISTS);
            }
            return new Error($msg, Constant::E_FILE_EXISTS);
        }

        // PhpErrorHandler traps php errors if any and saves to $phpErrHandler->lastError
        $phpErrHandler = new PhpErrorHandler();
        $res = $phpErrHandler->call(function()use($data, $file){
            return file_put_contents($file, $data);
        });
        if(false === $res) {
            // Create an error message including the error message generated by the 'rename()' 
            // function in the closure function above and saved to $phpErrHandler->lastError
            $errno = Constant::E_FILE_WRITE;
            $msg = $phpErrHandler->getErrorMsg("file_put_contents() method failed", "Cannot write data to file '{$file}'");
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, $errno);
            }
            return new Error($msg, $errno);
        }
        return $res;
    }

    /**
     * Deletes (unlinks) a file.
     *
     * @param string   $file   File path to delete.
     *
     * @return boolean Returns TRUE on success, FALSE on fail.
     */
    public static function deleteFile($file) {
        if(!is_string($file) || !strlen(trim($file))) {
            $var = Types::getVarType($file);
            $msg = "cannot delete: invalid file/path parameter '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }

        if(false === file_exists($file)) {
            return true;
        }

        if(! self::canLock($file)) {
            $msg = 'permission denied';
            $code = Constant::E_ACCESS_DENIED;
        }
        else {
            // PhpErrorHandler traps php errors if any and saves to $phpErrHandler->lastError
            $phpErrHandler = new PhpErrorHandler();
            $unlink = $phpErrHandler->call(function()use($file){
                return unlink($file);
            });
            if($unlink) {
                return true;
            }
            $msg = $phpErrHandler->getErrorMsg("method 'unlink()' failed", 'cannot delete');
            $code = Constant::E_FILE_DELETE;
        }
        if(self::$_throwErrors) {
            throw new Exception\RuntimeException($msg, $code);
        }
        return new Error($msg, $code);
    }

    /**
     * Use this to determine file lock eligibility.
     * @param string $file      File to check lock eligibility.
     * @param int    $operation (optional) flock() operation.
     */
    public static function canLock($file, $operation = LOCK_EX | LOCK_NB) {
        if(! is_string($file) || !strlen(trim($file))) {
            $var = Types::getVarType($file);
            $msg = "cannot chack lock status: invalid file/path parameter '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        
        if(! file_exists($file) || ! is_file($file)) {
            return false;
        }
        
        // PhpErrorHandler traps php errors if any and saves to $phpErrHandler->lastError
        $phpErrHandler = new PhpErrorHandler();
        $handle = $phpErrHandler->call(function()use($file){
            return fopen($file, 'a+');
        });
        if(false === $handle) {
            return false;
        }
        // Check lock-file eligible. See: php.net/manual/en/function.flock.php
        $flock = $phpErrHandler->call(function()use($handle, $operation){
            return flock($handle, $operation);
        });
        if($flock) {
            // Unlock the file.
            $flock = $phpErrHandler->call(function()use($handle){
                return flock($handle, LOCK_UN);
            });
            $canLock = true;
        }
        else {
            $canLock = false;
        }
        $close = $phpErrHandler->call(function()use($handle){
            return fclose($handle);
        });
        return $canLock;
    }
    
    /**
     * Creates a directory
     *
     * @param string  $directory Directory to create.
     * @param int     $mode      (optional) File mode. Default 0x1ff = 0777 octal
     * @param boolean $recursive (optional) Creates parent directories in the path if they don't exist.
     *
     * @return boolean
     */
    public static function createDirectory($directory, $mode = 0x1ff, $recursive = false) {
        if(!is_string($directory) || !strlen(trim($directory))) {
            $var = Types::getVarType($directory);
            $msg = "cannot create directory: invalid file/path parameter '{$var}'";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        // PhpErrorHandler traps php errors if any and saves to $phpErrHandler->lastError
        $phpErrHandler = new PhpErrorHandler();
        $res = $phpErrHandler->call(function()use($directory, $mode, $recursive){
            return mkdir($directory, $mode, $recursive);
        });
        if($res) {
            return true;
        }
        $msg = $phpErrHandler->getErrorMsg("mkdir() method failed", "cannot create directory '{$directory}'");
        if(self::$_throwErrors) {
            throw new Exception\RuntimeException($msg, Constant::E_DIRECTORY_CREATE);
        }
        return new Error($msg, Constant::E_DIRECTORY_CREATE);
    }

    /**
     * Creates a temporary file in the specified directory. mktemp method uses PHP's 'tempnam()' function.
     * Unlike method 'tmpfile()', 'tempnam()' does not open the file nor delete the file when it
     * is closed or when the script terminates.
     *
     * @param string  $directory    (optional) Directory in which to create temporary file.
     * @param string  $filePrefix   (optional) A prefix prepended to the file name.
     * @param boolean $keep         (optional) Keep the file; don't delete on PHP exit.
     * @param int     $fileMode     (optional) File mode (permissions) which to have 'chmod()' modify the file permissions mode.
     *
     * @return string  Returns the path of the temporary file.
     *
     */
    public static function createTempFile($directory = null, $filePrefix = "pcc", $keep = false, $fileMode = null) {
        if(null !== $directory) {
            $realPath = (is_string($directory) && strlen($directory)) ? realpath($directory) : '';
            if(!is_string($realPath) || !strlen(trim($realPath))) {
                $var = Types::getVarType($directory);
                $msg = "cannot create temporary file: invalid path parameter '{$var}'";
                if(self::$_throwErrors) {
                    throw new Exception\InvalidArgumentException($msg, Constant::E_FILE_NOT_FOUND);
                }
                return new Error($msg, Constant::E_FILE_NOT_FOUND);
            }
            $directory = $realPath;
        }

        if(null !== $fileMode && (! is_numeric($fileMode) || ($mode = intval($fileMode)) < 0 || $mode >= 0x7fff)) {
            // invalid '%s' parameter '%s'
            $msg = sprintf(Constant::T_PARAMETER_INVALID, 'fileMode', Types::getVartype($fileMode)) . ": expecting a file mode integer";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        
        // PhpErrorHandler traps php errors if any and saves to $phpErrHandler->lastError
        $phpErrHandler = new PhpErrorHandler();
        // NOTE: tempnam CREATES the file with unique name in the path specified.
        $tmpfile = $phpErrHandler->call(function()use($directory, $filePrefix) {
            return tempnam($directory, $filePrefix);
        });
        if(! $tmpfile) {
            $msg = $phpErrHandler->getErrorMsg("'tempnam()' method failed", "cannot create temporary file");
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, Constant::E_FILE_MKTEMP);
            }
            return new Error($msg, Constant::E_FILE_MKTEMP);
        }
        
        if(isset($mode)) {
            // NOTE: tempnam CREATES the file with unique name in the path specified.
            $res = $phpErrHandler->call(function()use($tmpfile, $mode) {
                return chmod($tmpfile, $mode);
            });
            if(! $res) {
                $msg = $phpErrHandler->getErrorMsg("chmod() method failed", "cannot set file mode to '{$mode}' for file '{$tmpfile}'");
                $phpErrHandler->call(function()use($tmpfile) {
                    return unlink($tmpfile);
                });
                if(self::$_throwErrors) {
                    throw new Exception\RuntimeException($msg, Constant::E_FILE_MKTEMP);
                }
                return new Error($msg, Constant::E_FILE_MKTEMP);
            }
        }
        
        if(! $keep) {
            if(! self::$_shutdownInit) {
                self::$_shutdownInit = true;
                register_shutdown_function(array(__CLASS__, '_shutdownFunction'));
            }
            self::$_shutdown['file'][] = $tmpfile;
        }
        
        return $tmpfile;
    }
    
    /**
     * Creates a directory including subdirectories.
     *
     * @param string $directory Directory to create.
     * @param int    $perm      Permissions to apply to created directory. Default 0x1ff = 0777 octal.
     *
     * @return boolean Return TRUE if successful else FALSE.
     */
    public static function makeDir($directory, $perm = 0x1ff) { // 0x1ff = 0777 octal

        if(! is_string($directory) || ! strlen(trim($directory))) {
            $badParam = 'directory';
            $expect = "a file path string";
        }
        elseif(!is_numeric($perm) || ($mode = intval($perm)) < 0 || $mode >= 0x7fff) {
            $badParam = 'perm';
            $expect = "a file permission mode number";
        }
        if(isset($badParam)) {
            // invalid '%s' parameter '%s'
            $msg = sprintf(Constant::T_PARAMETER_INVALID, $badParam, Types::getVartype($$badParam));
            if(isset($expect)) {
                $msg .= ': expecting ' . $expect;
            }
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        
        // PhpErrorHandler traps php errors if any and saves to $phpErrHandler->lastError
        $phpErrHandler = new PhpErrorHandler();
        
        $root = System::getServerAbsPath();

        // Convert path to relative to deal with systems that don't work properly with full paths.
        if(strpos($directory, $root) === 0) {
            $directory = './' . substr($directory, strlen($root) + 1);
            $oldDirectory = getcwd();
            $res = $phpErrHandler->call(function()use($root) {
                return chdir($root);
            });
            if(! $res) {
                // invalid '%s' parameter '%s'
                $msg = sprintf(Constant::T_PARAMETER_INVALID, $badParam, Types::getVartype($$badParam));
                if(isset($expect)) {
                    $msg .= ': expecting ' . $expect;
                }
                $phpErrHandler->getErrorMsg('chdir() method failed', $msg);
                if(self::$_throwErrors) {
                    throw new Exception\RuntimeException($msg, Constant::E_PARAMETER_INVALID);
                }
                return new Error($msg, Constant::E_PARAMETER_INVALID);
            }
        }
        
        if(!is_dir($directory)) {
            if(self::osWindows() && preg_match('/^([a-zA-Z]:)(.*)$/', $directory, $matches)) {
                if(! is_dir($matches[1] . DIRECTORY_SEPARATOR)) {
                   // cannot delete file
                   // file not found '%s': %s
                    $msg = sprintf(Constant::T_FILE_NOT_FOUND, Types::getVartype($directory), "invalid drive specifier '{$matches[1]}'");
                    if(self::$_throwErrors) {
                        throw new Exception\RuntimeException($msg, Constant::E_PATH_NOT_FOUND);
                    }
                    return new Error($msg, Constant::E_PATH_NOT_FOUND);
                }
            }
            $directory = self::getRealPath($directory, '/');
            $path = '';
            $dir_arr = [];
            if(strstr($directory, '/')) {
                $dir_arr = explode('/', $directory);
            }
            else {
                $dir_arr[] = $directory;
            }

            foreach($dir_arr as $k => $v) {
                $path .= ( empty($k) ? '' : '/') . $v;
                if(!is_dir($path)) {
                    /**
                     * umask
                     * 
                     * For files:
                     *    a umask of zero will cause all files to be created as 0666 or world-writable. 
                     * 
                     * For directories:
                     *    directories created while umask is 0 will be 0777.
                     */
                    umask(0); // Set directory permissions to allow all-world-writable.
                    // NOTE: tempnam CREATES the file with unique name in the path specified.
                    $res = $phpErrHandler->call(function()use($path, $mode) {
                        return mkdir($path, $mode);
                    });
                    if(! $res) {
                        $msg = $phpErrHandler->getErrorMsg("mkdir() method failed", 'cannot create directory');
                        if(!empty($oldDirectory)) {
                            $phpErrHandler->call(function()use($oldDirectory) {
                                return chdir($oldDirectory);
                            });
                        }
                        if(self::$_throwErrors) {
                            throw new Exception\RuntimeException($msg, Constant::E_DIRECTORY_CREATE);
                        }
                        return new Error($msg, Constant::E_DIRECTORY_CREATE);
                    }
                }
            }
        }
        if(!empty($oldDirectory)) {
            $phpErrHandler->call(function()use($oldDirectory) {
                return chdir($oldDirectory);
            });
        }
        return true;
    }

    /**
     * Backs up a file to a temporary file path.
     *
     * @param string $file        File to backup.
     * @param string $filePrefix  A prefix prepended to the file name.
     *
     * @return string  Returns the name of the backup file.
     */
    public static function backupFileToTemp($file, $filePrefix = "") {
        if(! is_string($file) || ! strlen($filename = trim($file))) {
            $badParam = 'file';
            $expect = 'a file path string';
        }
        elseif(! is_string($filePrefix)) {
            $badParam = 'filePrefix';
            $expect = 'a file path prefix string';
        }
        if(isset($badParam)) {
            // invalid '%s' parameter '%s'
            $msg = sprintf(Constant::T_PARAMETER_INVALID, $badParam, Types::getVartype($$badParam));
            if(isset($expect)) {
                $msg .= ': expecting ' . $expect;
            }
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        
        $phpErrHandler = new PhpErrorHandler();
        $res = $phpErrHandler->call(function()use($filename) {
            return is_file($filename);
        });
        if(!$res) {
            $msg = $phpErrHandler->getErrorMsg("file not found", 'the parameter is not a file');
            // The file is not found.
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, Constant::E_FILE_NOT_FOUND);
            }
            return new Error($msg, Constant::E_FILE_NOT_FOUND);
        }
        
        $dir = dirname($filename);
        $prefix = trim($filePrefix);
        $backupFile = $phpErrHandler->call(function()use($dir, $prefix) {
            return tempnam($dir, $prefix) ;
        });
        if(!$backupFile) {
            $msg = $phpErrHandler->getErrorMsg("method 'tempnam()' failed", 'cannot create temporary file');
            // The file is not found.
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, Constant::E_FILE_MKTEMP);
            }
            return new Error($msg, Constant::E_FILE_MKTEMP);
        }

        $res = $phpErrHandler->call(function()use($filename, $backupFile) {
            return copy($filename, $backupFile) ;
        });
        if($res) {
            return $backupFile;
        }
        
        // an error occurred copying a file.
        $msg = $phpErrHandler->getErrorMsg("method 'copy()' failed", 'an error occurred copying a file');
        $phpErrHandler->call(function()use($backupFile) {
            return unlink($backupFile) ;
        });
        if(self::$_throwErrors) {
            throw new Exception\RuntimeException($msg, Constant::E_FILE_COPY);
        }
        return new Error($msg, Constant::E_FILE_COPY);
    }

    /**
     * Copies data from a readable stream to a writable stream. The file positions are not reset
     * so data is copied from current positions.
     *
     * @param string  $infile        A readable stream resource from which the data is copied.
     * @param string  $outfile       A writeable stream resource to which the data is copied.
     * @param int     $maxFileSize   The maximum allowed number of bytes to copy else error thrown. Default = -1
     *
     * @return int  Returns the number of bytes copied.
     */
    public static function streamCopyToStream($infile, $outfile, $maxFileSize = -1) {
        if(!is_resource($infile)) {
            $badParam = 'infile';
            // bad source file resource handle
            $code = Constant::E_BAD_SOURCE_RESOURCE;
        }
        elseif(!is_resource($outfile)) {
            $badParam = 'outfile';
            // Bad destination file resource handle.
            $code = Constant::E_BAD_DEST_RESOURCE;
        }
        if(isset($badParam)) {
            // T_BAD_RESOURCE = "invalid file resource handle parameter '%s': '%s'"
            $msg = sprintf(Constant::T_BAD_RESOURCE, $badParam, Types::getVartype($$badParam));
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, $code);
            }
            return new Error($msg, $code);
        }
        
        if(! is_numeric($maxFileSize)) {
            if(null === $maxFileSize) {
                $maxFileSize = -1;
            }
            else {
                $badParam = 'maxFileSize';
            }
        }
        else {
            $maxFileSize = floatval($maxFileSize);
            if(! $maxFileSize) {
                $badParam = 'maxFileSize';
            }
        }
        if(isset($badParam)) {
            $expect = "a number >0 or -1";
            // invalid '%s' parameter '%s'
            $msg = sprintf(Constant::T_PARAMETER_INVALID, $badParam, Types::getVartype($$badParam)) . ": expecting " . $expect;
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }

        /*
          stream_copy_to_stream() uncompresses 'ZLIB' and 'GZIP' files automatically
          when the file's meta data 'stream_type' property indicates the file is
          compressed in an algorithm supported by one of PHP's file stream wrappers.
         */
        $size = ($maxFileSize <= 0) ? -1 : ($maxFileSize + 1);
        $phpErrHandler = new PhpErrorHandler();
        $copyCount = $phpErrHandler->call(function()use($infile, $outfile, $size) {
            return stream_copy_to_stream($infile, $outfile, $size);
        });
        if(false === $copyCount || $copyCount < 0) {
            $msg = $phpErrHandler->getErrorMsg("method 'stream_copy_to_stream()' failed", 'an error occurred in a file or socket');
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_FILE_COPY);
            }
            return new Error($msg, Constant::E_FILE_COPY);
        }

        if(-1 != $maxFileSize && $copyCount > $maxFileSize) {
            // file size too large
            // the size of the file exceeds the specified maximum of '%s'
            $msg = sprintf(Constant::T_FILE_TOO_LARGE, $maxFileSize);
            if(self::$_throwErrors) {
                throw new Exception\RuntimeException($msg, Constant::E_FILE_TOO_LARGE);
            }
            return new Error($msg, Constant::E_FILE_TOO_LARGE);
        }

        return $copyCount;
    }

    /**
     * Use this to prevent overwrite of an existing file. Checks existence of a pathname. 
     * If the path exists, creates a unique name and returns that name.
     *
     * @param string $pathname    Directory in which to create a unique filename.
     * @param string $prefix      (optional) Prefix prepended to unique name.
     * @param int    $maxAttempts (optional) Maximum number of attempt to create unique filename before abort.
     *
     * @return string  Returns the unique filename.
     */
    public static function getUniqueFilename($pathname, $prefix = 'copy_of_', $maxAttempts = 0x100000) {
        /**
         * Parameter validation.
         */
        if(! is_string($pathname) || ! strlen($originalPath = trim($pathname))) {
            $badParam = 'pathname';
            $expect = "a file path string";
        }
        elseif(! file_exists($originalPath) || ! is_file($originalPath)) {
            $badParam = 'pathname';
            $expect = "expecting a file that exists";
        }
        elseif(! is_string($prefix)) {
            if(null === $prefix) {
                $prefix = '';
            }
            else {
                $badParam = 'prefix';
                $expect = "a file name prefix string";
            }
        }
        elseif(! is_numeric($maxAttempts) || ($max = intval($maxAttempts)) < 1) {
            $badParam = 'maxAttempts';
            $expect = "an integer greater then zero";
        }
        if(isset($badParam)) {
            // invalid '%s' parameter '%s'
            $msg = sprintf(Constant::T_PARAMETER_INVALID, $badParam, Types::getVartype($$badParam));
            if(isset($expect)) {
                $msg .= ": expecting " . $expect;
            }
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        
        $dirname = self::addPathSlash(dirname($originalPath));
        $basename = self::getFileBasename($originalPath);
        $extension = self::getFileExtension($originalPath, true);
        $newName = $basename;
        if(! Types::isBlank($prefix)) {
            $newName = trim($prefix) . $basename;
        }
        $newBase = $newName;
        for($index = 2, $endIndex = $max + 2; $index < $endIndex; $index++) {
            $newPath = $dirname . $newName . $extension;
            if(! file_exists($newPath)) {
                return $newPath;
            }
            $newName = $newBase . "(" . $index . ")";
        }
        // T_CREATE_UNIQUE_MAXED = "cannot create unique filename after %s attempts in the specified path '%s'"
        $msg = sprintf(Constant::T_CREATE_UNIQUE_MAXED, $max, $dirname);
        if(self::$_throwErrors) {
            throw new Exception\RuntimeException($msg, Constant::E_CREATE_UNIQUE);
        }
        return new Error($msg, Constant::E_CREATE_UNIQUE);
    }

    /**
     * Expands all symbolic links and resolves references to '/./', '/../' and extra '/'
     * characters in the input path and returns the canonicalized absolute pathname.
     *
     * @param string $path       Path of file to expand.
     * @param string $delimiter  Path delimiter.
     *
     * @return string Return expanded pathname.
     */
    public static function getRealPath($path, $delimiter = "/") {
        if(! is_string($path) || ! strlen(trim($path))) {
            $param = 'path';
            $expect = 'a file path string';
        }
        elseif(! is_string($delimiter)) {
            if(null === $delimiter) {
                $delimiter = '/';
            }
            else {
                $param = 'delimiter';
                $expect = "a path delimiter string";
            }
        }
        if(isset($param)) {
            // invalid '%s' parameter '%s'
            $msg = sprintf(Constant::T_PARAMETER_INVALID, $param, Types::getVartype($$param));
            if(! empty($expect)) {
                $msg .= ": expecting " . $expect;
            }
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }

        $path = preg_replace("/[\\\\\/]+/S", $delimiter, $path);
        $parts = explode($delimiter, $path);

        $real_path = [];
        if(Types::isBlank($parts[0])) {
            $real_path[] = '';
        }
        foreach($parts as $p) {
            $trimmed = trim($p);
            if($trimmed == '..') {
                if(end($real_path) == '..' || !array_pop($real_path)) {
                    $real_path[] = '..';
                }
            }
            elseif($trimmed != '' && $trimmed != '.') {
                $real_path[] = $p;
            }
        }

        if(Types::isBlank(end($parts))) {
            $real_path[] = '';
        }

        return (!strlen(implode("", $real_path))) ? "" : implode($delimiter, $real_path);
    }
    
    /**
     * Merges/joins multiple filesysem paths specified in a variable-length argument list.
     *
     * @param string        $delimiter  The delimiter with which to join paths.
     * @param string|array  $path1      The first path to merge.
     * @param string|array  $path2      Second path to merge etc...
     *
     * @return string    Returns the merged paths.
     */
    public static function joinPath($delimiter /*,path,path2,...*/) {
        $numArgs = func_num_args();
        if(! $numArgs) {
            return '';
        }
        $args = func_get_args();
        if(is_string($delimiter) && ('\\' === $delimiter || '/' === $delimiter)) {
            if(--$numArgs < 1) {
                return $delimiter;
            }
            array_shift($args); // Remove delimiter.
        }
        else {
            $delimiter = '/';
        }

        // Exit if < 2 parts.
        if(! count($args)) {
            return '';
        }
        $spaceSlashes = '/ \\t\\n\\r\\0\\x0B';
        
        // Pre-process to collect non-empty path parts.
        $pre = [];
        $start = -1; // Save starting offset non-space/slash
        foreach($args as $arg) {
            if(! is_array($arg)) {
                $arg = array($arg);
            }
            for($i = 0; $i < count($arg); $i++) {
                // Replace windows back-slashes.
                $val = str_replace('\\', '/', trim(strval($arg[$i])));
                if(strlen($val)) {
                    // All spaces, slashes?
                    $t = trim($val, $spaceSlashes);
                    $c = count($pre);
                    if(strlen($t)) {
                        if($start < 0) {
                            $start = $c; // Save starting offset non-space/slash
                        }
                    }
                    $pre[] = $val;
                }
            }
        }
        if(count($pre) < 2) {
            return count($pre) ? reset($pre) : '';
        }
        if($start < 0) {
            return implode('', $pre);
        }

        // Grab leading slashes if any and the first non-slash and strip its right slashes.
        $parts = [rtrim(implode('', array_slice($pre, 0, ++$start)), '/')];
        $pre = array_slice($pre, $start);
        $c = count($pre);
        $tail = '';
        for($i = $c - 1; $i >= 0; $i--) {
            $t = trim($pre[$i], $spaceSlashes);
            if(strlen($t)) {
                $tail = implode('', array_slice($pre, ++$i, $c - $i));
                $pre = array_slice($pre, 0, $i);
                break;
            }
        }
        if(count($pre)) {
            $paths = [];
            array_walk($pre, function(&$val) use(&$paths) {
                $val = trim($val, '/');
                if(strlen($val)) {
                    $paths[] = $val;
                }
            });
            if(count($paths)) {
                $parts[] = implode('/', $paths);
            }
        }
        if(strlen($tail)) {
            $parts[count($parts) - 1] .= $tail;
        }
        $result = implode('/', $parts);
        if('/' !== $delimiter) {
            $result = str_replace('/', $delimiter, $result);
        }
        return $result;
    }

    /**
     * Removes trailing slash(es) from a pathname.
     *
     * @param string $path   The path from which to remove trailing slashes.
     *
     * @return string Returns path with trailing slashes removed.
     */
    public static function removePathSlash($path) {
        $strPath = self::_toString($path);
        if(is_null($strPath)) {
            // invalid '%s' parameter '%s'
            $msg = "cannot remove path slash: " . sprintf(Constant::T_PARAMETER_INVALID, 'path', Types::getVartype($path)) 
                . ": expecting file path string";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        $n = strlen($strPath = trim($strPath));
        if(!$n) {
            return "";
        }
        $c = substr($strPath, --$n, 1);
        if(false === strpos('/\\', $c)) {
            return $strPath;
        }
        $strPath = preg_replace('@^(.*?)([/\\\\]+)$@', "$1", $strPath);
        return strlen($strPath) ? $strPath : $c;
    }

    /**
     * Removes leading slash(es) from a pathname.
     *
     * @param string $path   The path from which to remove leading slashes.
     *
     * @return string Returns path with leading slashes removed.
     */
    public static function removeLeadingSlashes($path) {
        $strPath = self::_toString($path);
        if(is_null($strPath)) {
            // invalid '%s' parameter '%s'
            $msg = "cannot remove leading path slashes: " . sprintf(Constant::T_PARAMETER_INVALID, 'path', Types::getVartype($path)) 
                . ": expecting file path string";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        if(! $n = strlen($strPath = ltrim($strPath))) {
            return "";
        }
        $c = substr($strPath, 0, 1);
        if(false === strpos('/\\', $c)) {
            return $strPath;
        }
        $strPath = ltrim($strPath, '/\\');
        return strlen($strPath) ? $strPath : $c;
    }

    /**
     * Appends a slash to a path when the path does not have a trailing slash.
     *
     * @param string $path   Path for which to append a slash.
     * @param string $delim  The delimiter slash to append to the path.
     *
     * @return string    Returns path with slash appended.
     */
    public static function addPathSlash($path, $delim = null) {
        $strPath = self::_toString($path);
        if(is_null($strPath)) {
            // invalid '%s' parameter '%s'
            $msg = "cannot add path slash: " . sprintf(Constant::T_PARAMETER_INVALID, 'path', Types::getVartype($path)) 
                . ": expecting file path string";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        if(! $n = strlen($strPath = rtrim($strPath))) {
            return '';
        }
        if(! is_string($delim)) {
            $delim = (false === strpos($strPath, '\\')) ? '/' : '\\';
        }
        $c = substr($strPath, --$n, 1);
        if($c != $delim && $c != (('/' == $delim) ? '\\' : '/') && $c != ':') {
            $strPath .= $delim;
        }
        return $strPath;
    }

    /**
     * Returns the base filename part without the extension. Returns empty string if no path expression.
     *
     * @param string $path   The path for which to get the file base name.
     *
     * @return string    Returns the file base name.
     *
     * PHP's pathinfo() method returns an array:
     *     [dirname]   => c:\temp
     *     [basename]  => base.foo.bar
     *     [extension] => bar
     */
    public static function getFileBasename($path) {
        $strPath = self::_toString($path);
        if(is_null($strPath)) {
            // invalid '%s' parameter '%s'
            $msg = "cannot get file basename: " . sprintf(Constant::T_PARAMETER_INVALID, 'path', Types::getVartype($path)) 
                . ": expecting file path string";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        if(! $n = strlen($strPath = trim($strPath))) {
            return '';
        }
        return pathinfo($strPath, PATHINFO_FILENAME);
    }

    /**
     * Returns the extension part of a pathname with a dot(.) appended when 'add_dot' is true.
     *
     * @param string  $path   The path for which to get the file extension.
     * @param boolean $addDot Prepend a dot (period) to the returned file extension.
     *
     * @return string    Returns the file extension
     */
    public static function getFileExtension($path, $addDot = false) {
        $strPath = self::_toString($path);
        if(is_null($strPath)) {
            // invalid '%s' parameter '%s'
            $msg = "cannot get file extension: " . sprintf(Constant::T_PARAMETER_INVALID, 'path', Types::getVartype($path)) 
                . ": expecting file path string";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        if(! strlen($strPath = trim($strPath))) {
            return '';
        }
        if(! strlen(trim($e = pathinfo($strPath, PATHINFO_EXTENSION)))) {
            return '';
        }
        if($addDot) {
            $e = "." . $e;
        }
        return $e;
    }

    /**
     * Prepends dot to, or removes dot from a file string.
     *
     * @param string   $ext    Extension string to which to prepend a dot.
     * @param boolean  $remove (optional) When TRUE removes leading dots and white space.
     *
     * @return string  Returns file extension string.
     */
    public static function fileExtDot($ext, $remove = false) {
        $strExt = self::_toString($ext);
        if(is_null($strExt)) {
            // invalid '%s' parameter '%s'
            $msg = "cannot prepend/remove file extension dot: " . sprintf(Constant::T_PARAMETER_INVALID, 'ext', Types::getVartype($ext)) 
                . ": expecting file extension string";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        if(! strlen($strExt = ltrim($strExt))) {
            return '';
        }
        $strExt = ltrim($strExt, '.');
        if($remove || ! strlen($strExt)) {
            return $strExt;
        }
        return "." . $strExt;
    }

    /**
     * Attempts to determine a file's MIME type.
     *
     * @param string $file
     *
     * @return boolean|string Returns the MIME type or false if not found.
     */
    public static function getFileMimeType($file) {
        if(! is_string($file) || ! strlen(trim($file)) || ! file_exists($file) || ! is_file($file)) {
            // invalid '%s' parameter '%s'
            $msg = sprintf(Constant::T_PARAMETER_INVALID, 'file', Types::getVartype($file)) . ": expecting existing file";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        $fileInformation = new FileInformation();
        $return = $fileInformation->getFileMimeType($file);
        return $return;
    }

    /**
     * Returns a description for the specified file extension.
     * @param string $fileExtension The file extension for which to find description.
     * @return string
     */
    public static function getFileExtensionDescription($fileExtension) {
        if(! is_string($fileExtension) || ! strlen($ext = trim($fileExtension))) {
            // invalid '%s' parameter '%s'
            $msg = sprintf(Constant::T_PARAMETER_INVALID, 'fileExtension', Types::getVartype($fileExtension)) . ": expecting a string file extension";
            if(self::$_throwErrors) {
                throw new Exception\InvalidArgumentException($msg, Constant::E_PARAMETER_INVALID);
            }
            return new Error($msg, Constant::E_PARAMETER_INVALID);
        }
        $fileInformation = new FileInformation();
        $return = $fileInformation->getFileExtensionDescription($fileExtension);
        return $return;
    }
    
    /**
     * Returns the debug message if any.
     * @return array
     */
    public static function getDebugMessages() {
        return self::$_debug_msg;
    }

    /**
     * Returns the flag that indicates debug mode ON/OFF.
     * @return boolean
     */
    public static function getDebug() {
        return self::$_debug;
    }

    /**
     * Sets the flag that indicates debug mode ON/OFF.
     *
     * @param boolean $debug  The flag that indicates debug mode ON/OFF.
     */
    public static function setDebug($debug) {
        self::$_debug = (bool)$debug;
    }

    /**
     * Shutdown function to delete temporary files.
     */
    public static function _shutdownFunction() {
        if(is_array(self::$_shutdown['file']) && count(self::$_shutdown['file'])) {
            foreach(self::$_shutdown['file'] as $file) {
                if(file_exists($file) && is_file($file)) {
                    unlink($file);
                }
            }
        }
    }
    
    /**
     * @return boolean   Returns TRUE when the OS is MS.
     */
    private static function osWindows() {
        if(is_null(self::$_osWindows)) {
            /* php_uname 'mode' parameter is a single character that defines what information is returned:             
                a  This is the default. Contains all modes in the sequence "s n r v m".
                s  Operating system name. eg. FreeBSD.
                n  Host name. eg. localhost.example.com.
                r  Release name. eg. 5.1.2-RELEASE.
                v  Version information. Varies a lot between operating systems.
                m  Machine type. eg. i386.
            */
            // Samples returned by php_uname("s"): 'FreeBSD', 'Wndoze NT'
            self::$_osWindows = (false !== strpos(strtolower(php_uname("s")), "win"));
        }
        return self::$_osWindows;
    }

    /**
     * 
     */
    private static function _toString($var, $acceptNumeric = false) {
        if(is_string($var)) {
            return $var;
        }
        if(is_array($var) || is_resource($var)) {
            return null;
        }
        if(is_object($var)) {
            if(method_exists($var, '__toString')) {
                return (string)$var;
            }
            return null;
        }
        if(! is_scalar($var) || ! $acceptNumeric) {
            return null;
        }
        return (false === settype($var, 'string')) ? null : $var;
    }
}
